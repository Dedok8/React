import "./App.css";
import Calculator from "./components/Calc/Calculator1.jsx";
import MainBlock from "./components/MainBlock/MainBlock.jsx";
import styles from "./components/MainBlock/mainBlock.module.css";

function App() {
  return (
    <>
      <div className={styles["container"]}>
        <MainBlock
          title="Задача 1. Оптимізація вибіркового рендеру з useMemo та React.memo "
          description={
            "Створіть компонент-калькулятор, який має два незалежні поля вводу: одне для числа A і одне для числа B. Також є окремий компонент ResultDisplay, який відображає A + B. Обгорніть ResultDisplay у React.memo(). Використайте useMemo в батьківському компоненті, щоб обчислити A + B і передати цей результат до ResultDisplay. Переконайтеся, що ResultDisplay ререндериться лише тоді, коли змінюються A або B, а не коли змінюється інший незалежний стан у батьківському компоненті (наприклад, лічильник, що не впливає на A чи B)."
          }
        >
          <Calculator />
        </MainBlock>
      </div>
      <div className={styles["container"]}>
        <MainBlock
          title="Задача 2. Таблиця з фільтрацією та сортуванням, чутлива до UI "
          description={`Створіть компонент DataGrid (батьківський) та GridRow (дочірній).
            DataGrid отримує великий масив даних, має поле вводу для фільтрації, кнопки для сортування за різними колонками.
            GridRow (обгорнутий у React.memo) відображає один рядок даних.
            Використайте useDeferredValue для пошукового запиту та/або параметрів сортування.
            Використайте useMemo для обчислення відфільтрованих та відсортованих даних на основі відкладених значень.
            Використайте useCallback для функцій-обробників сортування та інших інтерактивних елементів, які передаються до дочірніх компонентів.
            Мета: забезпечити швидкий відгук на введення та кліки, навіть якщо обробка даних займає час.`}
        >
          <DataGrid />
        </MainBlock>
      </div>
      <div className={styles["container"]}>
        <MainBlock
          title="Задача 3. useWindowSize – розмір вікна браузера "
          description={`Створіть кастомний хук useWindowSize, який повертає поточну ширину та висоту вікна браузера. Він повинен оновлюватися при зміні розміру вікна.
          Створіть компонент, який відображає поточні розміри вікна браузера (ширина x висота), використовуючи useWindowSize. На основі розмірів відображати іконки монітора, планшета або телефона.
          `}
        >
          <Window />
        </MainBlock>
      </div>
      <div className={styles["container"]}>
        <MainBlock
          title="Задача 4. useDebounce – відкладений виклик функції"
          description={`Створіть кастомний хук useDebounce, який приймає значення та затримку в мілісекундах. Він повинен повертати "відкладене" значення, яке оновлюється лише після того, як минув заданий час без змін.
          Створіть поле пошуку, де результати пошуку оновлюються не відразу після кожного символу, а з невеликою затримкою (наприклад, 500мс) після зупинки введення, використовуючи useDebounce.
            `}
        >
          <Debounce />
        </MainBlock>
      </div>
    </>
  );
}

export default App;
